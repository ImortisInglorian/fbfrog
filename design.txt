How about using existing C preprocessors/parser (e.g. libclang)
+ not really fully investigated yet
+ less work, more complete and less bugs than a custom parser
- dependency on external tool/library makes development/distribution/usage more
  difficult
- fbfrog needs to see #defines, typically pre-existing C-to-AST parsers don't
  preserve them

Using an AST instead of just "rearranging tokens" or doing text replacements
+ Complex C constructs (nested function pointer declarations & co) require a
  recursive parser, and can only be represented as a tree
+ Allows high-level steps such as replacing identifiers of certain symbols to
  work with the AST instead of tokens

Storing AST in "API files" in some intermediate format (which is not the final
.bi) to make later translations of the same API easier, by no longer requiring
the original tarballs for which "API files" were once generated.
+ can keep "API files" in VCS, have to download much less tarballs
- such API files are final; they'd need to be regenerated in order to benefit
  from fbfrog fixes or preset changes (e.g. different pre-#defines). Easy to
  have hidden bugs thanks to this, and to be safe, they'd have to be regenerated
  every time, at which point they become pointless.

Re-importing existing FB binding in order to extend/update them
- Old bindings are likely to contain bugs or simply not conform to latest
  API/ABI requirements (e.g., 32bit FB headers use Integer in many places where
  int was used in C, but this would break for 64bit)
- Same as for the issue of "storing AST in some intermediate format": need to
  re-parse the original headers in order for fbfrog/preset updates to take effect

#includes are always parsed, so that any #defines/#undefs they contain are seen,
but the -nomerge option can be used to prevent the code they contain from being
preserved in the final binding.

Each input .h is a root header for which fbfrog will produce an AST representing
the API as seen from that root's point of view. Each root is emitted as separate
.bi because typically they'll be incompatible. Common parts of the root's APIs
will automatically be extracted into common headers. It's also possible to use
pre-#includes to concatenate separate roots manually.

Split fbfrog into separate tools: cpp, c2ast, ast2fb
+ Possible to tweak output of a tool before passing to next tool
+ Easier testing of individual steps
- Too much manual work needed when adjusting output between steps
- Internal representation exposed, may need to start maintaining compatibility etc.
- Not as easy to build & use anymore compared to having a single tool

Preserving white space (i.e. input C code's formatting) and commentary
- Creating bindings, not translations. Declarations may be re-ordered.

Should stop when encountering unknown constructs instead of recovering and
emitting the unknown construct into a comment in the .bi output, together with
a TODO note.
- Producing almost complete .bi output is better than none, can fix rest manually
- Need to support full C before having the problem go away, lots of work
+ Forces C parsing support to be improved. Any construct can be parsed, it just
  needs to be implemented.
+ Fixing unknown constructs manually is nice for one-time translation, but
  usually headers need updating/retranslation repeatedly; then the whole process
  should be automated.
