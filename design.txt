Design decisions
----------------

Using a custom C PP/parser instead of an existing one (e.g. libclang).
- not really fully investigated yet what all existing ones can do
- an existing parser would be less work and more complete, and have less bugs
  than a custom parser
+ dependency on external tool/library makes development/distribution/usage more
  difficult
+ fbfrog needs to see #defines, typically pre-existing C-to-AST parsers don't
  preserve them
+ fbfrog sometimes wants to allow conditional macro expansion (i.e. only expand
  certain macros, not others), that's probably not possible with existing CPPs

Using an AST instead of just "rearranging tokens" or doing text replacements
+ Complex constructs (e.g. nested function pointer declarations, or expression
  parsing and evaluation) require a recursive parser, and can only be
  represented as a tree. This is much nicer to do with a real tree data
  structure instead of a flat list of tokens.
+ Makes high-level analyses so much easier, e.g. replacing identifiers of
  certain symbols: only have to cycle through AST nodes, checking declaration
  type and touch the common identifier field; as opposed to re-parsing tokens
  everytime to determine symbol type, where to insert the new identifier, etc.

Not storing AST in "API files" in some intermediate format (which is not the
final .bi), even though that could make later translations of the same API
easier, by no longer requiring the original tarballs for which "API files" have
once been generated.
- Have to download/keep original headers/tarballs; "API files" on the other hand
  could be stored in Git etc.
+ Forces original headers to be re-interpreted everytime. This means they always
  benefit from fbfrog fixes or preset changes (e.g. different pre-#defines).
  "API files" are final though and thus would easily include hidden bugs. They'd
  need to be regenerated to avoid that, and at that point the original headers
  are needed anyways.

Not re-importing existing FB binding in order to extend/update them.
+ Old bindings are likely to contain bugs or simply not conform to latest
  API/ABI requirements (e.g., 32bit FB headers use Integer in many places where
  int was used in C, but this would break for 64bit)
+ Need to re-parse the original headers in order for fbfrog/preset updates to
  take effect.

#includes are always parsed, so that any #defines/#undefs they contain are seen,
but the -nomerge option can be used to prevent the code they contain from being
preserved in the final binding.

Each input .h is a root header for which fbfrog will produce an AST representing
the API as seen from that root's point of view. Each root is emitted as separate
.bi because typically they'll be incompatible. Common parts of the root's APIs
will automatically be extracted into common headers. It's also possible to use
pre-#includes to concatenate separate roots manually.

"Tiny" CLI to control fbfrog behaviour, instead of a bigger-scale custom
*.fbfrog file format/language (as "presets" or scripts).
+ Should use CLI for both small/big use cases, instead of having 2 things to do
  the same thing.
+ Support for @response files still allows big "presets" to be saved in files.
* Only makes sense when allowing only one "preset at a time, which is ok though.
+ CLI forces simplification of "preset" commands/options because there can't be
  much complexity (such as multiple levels of nested code blocks) on a command
  line.
- It's more difficult to specify complex #define bodies on the command line or
  in general, in a single line (including inside @files). And care must be taken
  with chars special to the shell or @file parser, so escaping may be needed.

Just one "preset" per fbfrog invocation.
+ Allows for the "tiny"/simple CLI
+ Matches the idea that fbfrog works much like a compiler: It takes various
  input files and generates a binding (one binding, not multiple ones).

fbfrog is a single tool, not split up into separate tools: cpp, c2ast, ast2fb
+ All-in-one program is easier to build & use
+ Internals hidden, can easily be changed. With separate tools it'd be necessary
  to start maintaining backwards compatibility etc.
- Prevents manual adjustments to output of individual steps.
+ Wanting to adjust output manually isn't good anyways, because it's too much
  manual work.
- Prevents easy testing of individual steps

No GUI
+ The old GUI was just a frontend for the CLI. Click together a list of input
  files, check some check boxes, click "Go!". That's not a useful GUI...
+ Anyone that wants to create bindings for FB but can't use the CLI can probably
  not be trusted to do a good job anyways
+ No serious ideas for a useful GUI.
  * Compare C headers + FB binding side-by-side, live? Many headers map to 1
    binding, difficult to visualize...
  * Show fbfrog errors inline in the C code, allowing right-clicking to tell
    fbfrog to ignore certain constructs, i.e. build up presets via mouse clicks?
    Lots of work to make an editor like that...

Not preserving white space (i.e. input C code's formatting) and commentary.
+ Creating bindings, not translations. Declarations may be re-ordered.

Should show an error when encountering unknown constructs instead of emitting
the unknown construct and a TODO note into a comment in the .bi output.
+ Forces C parsing support to be improved. Any construct can be parsed, it just
  needs to be implemented.
- Need to support full GCC style C before having the problem go away, that's a
  lot of work. For example inline functions etc. are likely too hard to
  translate properly automatically.
+ C parser is already good enough, unknown constructs are rare in comparison to
  known ones.
- Some constructs (e.g. #defines whose bodies aren't just expressions) cannot be
  supported automatically, they always must be fixed up by the user.
- Having a 90% ok result is better than no result at all. Remaining issues can
  be fixed manually.
+ User must specify proper command line options to fix/work around unknown
  constructs. This means the fixup becomes part of the preset and can easily be
  shared/repeated. Manually fixing unknown construct in the output .bi is not
  acceptable: The user must search through all output .bi files, fix up the
  constructs, and that every time the header is regenerated.

Similar to this: Not automatically/silently removing #defines whose bodies
couldn't be parsed.
+ Error message wouldn't be visible - no cause for exclusion shown = bad.
- Symbols are renamed automatically too

fbfrog should not worry about where input files come from (downloading and
extracting tarballs etc.). Headers may need all kinds of shell commands to be
extracted and prepared, perhaps even execution of a package-specific build
system. fbfrog shoudn't become a portable shell, but instead focus on its job.

It's good to have both -version and -target, without allowing any nesting except
-targets inside -versions.
+ Allowing arbitrary -version nesting has proven difficult for AST merging
  and #if generation code etc.
+ It adds a nesting level which avoids duplicate code... it is nicer than
  doing -version 1.win32 -version 1.linux etc. and that again for other
  versions.
+ target system definitely is the most common nesting within a single
  version, and pretty much the only that matters for FB. Though there also
  is the static vs DLL issue, encoding that into the -version has the same
  problem in the end.
+ -target could nicely be used to auto-add proper pre-#defines, and it's
  very nice for generating #ifdef __FB_WIN32__ etc. checks. Could also use
  -win32/-linux options to behave as if there were -define _WIN32 etc.
  pre-#defines at that position, but then -versiondefine __FB_WIN32__ etc.
  would have to be given manually.
+ -version 1.win32 etc. can still be used, if wanted, to specify all the
  pre-#defines manually.
+ But in general, fbfrog having basic compiler pre-#defines built-in is
  very useful. Otherwise every user would have to worry about them...
