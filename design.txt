How about integrating C parsing into fbc one way or another, so we can just
#include .h files directly?
+ Easier because no bindings need to be maintained. External C APIs can be used
  much faster (no waiting for the binding to be created/updated) and with much
  less trouble (no broken bindings, no incompatibilites due to mismatching
  versions, etc).
- Feels like giving up. fbc is the FB compiler, not a C compiler. FB itself
  should be good enough to specify the API/ABI for accessing external libraries.
  Having FB bindings enforces FB to be further improved in this aspect.
- Cannot re-use fbc's existing lex/pp code because it's way too FB-specific and
  that's way too different from C.
- Requires being able to specify #defines using C syntax & semantics either on
  the fbc command line or in FB code appearing above an #include "foo.h"
  statement, such that those #defines would be visible to the .h files. How
  should this be done?
* Maintaining a full CPP and C/C++ parser as part of fbc or as a separate tool
  is more or less the same amount of work.


fbfrog design decisions
-----------------------

Using a custom C PP/parser instead of an existing one (e.g. libclang).
- not really fully investigated yet what all existing ones can do
- an existing parser would be less work and more complete, and have less bugs
  than a custom parser
+ dependency on external tool/library makes development/distribution/usage more
  difficult
+ fbfrog needs to see #defines, typically pre-existing C-to-AST parsers don't
  preserve them
+ fbfrog sometimes wants to allow conditional macro expansion (i.e. only expand
  certain macros, not others), that's probably not possible with existing CPPs

Using an AST instead of just "rearranging tokens" or doing text replacements
+ Complex constructs (e.g. nested function pointer declarations, or expression
  parsing and evaluation) require a recursive parser, and can only be
  represented as a tree. This is much nicer to do with a real tree data
  structure instead of a flat list of tokens.
+ Makes high-level analyses so much easier, e.g. replacing identifiers of
  certain symbols: only have to cycle through AST nodes, checking declaration
  type and touch the common identifier field; as opposed to re-parsing tokens
  everytime to determine symbol type, where to insert the new identifier, etc.

Not storing AST in "API files" in some intermediate format (which is not the
final .bi), even though that could make later translations of the same API
easier, by no longer requiring the original tarballs for which "API files" have
once been generated.
- Have to download/keep original headers/tarballs; "API files" on the other hand
  could be stored in Git etc.
+ Forces original headers to be re-interpreted everytime. This means they always
  benefit from fbfrog fixes or preset changes (e.g. different pre-#defines).
  "API files" are final though and thus would easily include hidden bugs. They'd
  need to be regenerated to avoid that, and at that point the original headers
  are needed anyways.

Not re-importing existing FB binding in order to extend/update them.
+ Old bindings are likely to contain bugs or simply not conform to latest
  API/ABI requirements (e.g., 32bit FB headers use Integer in many places where
  int was used in C, but this would break for 64bit)
+ Need to re-parse the original headers in order for fbfrog/preset updates to
  take effect.

fbfrog's file model
* .h files given on the command line are "roots" which will be parsed into an
  AST representing the API that would become available to a program #including
  those headers.
* parsing roots includes the expansion of any #includes, so that as many
  #defines etc. as possible are visible to fbfrog's CPP. The -nomerge option can
  be used to prevent the code they contain from being preserved in the binding.
* 1 fbfrog invocation generates 1 binding, for exactly the API that'd be visible
  to programs #including the roots passed to fbfrog, with the pre-#defines
  passed to fbfrog, etc.
* If multiple roots are given, they'll just be concatenated and treated as one
  API, just like they'd be when #included into C code.
* Thus it doesn't make sense to pass incompatible headers to fbfrog at the same
  time.
* Generating 1 binding usually means generating 1 .bi file, however fbfrog
  allows even single bindings to be split (back) up into multiple .bi files if
  that's desired.
* Treating roots as separate incompatible APIs would allow for a -common option
  which would automatically extract common code from the separate bindings and
  create shared sub-headers. This is useless though: The -nomerge option is
  already enough to preserve the original header structure (even if it requires
  that fbfrog be invoked once for each API), and a -common code extraction
  algorithm wouldn't offer advantages, but only potentially break the original
  header structure, produce too many unwanted sub-headers, be too slow, etc.
* It wouldn't even help the binding creation process if fbfrog could see multiple
  separate APIs at once, because fbfrog already sees all code relevant to a
  binding by expanding all #includes.

"Tiny" CLI to control fbfrog behaviour, instead of a bigger-scale custom .fbfrog
file format/language (as "presets" or scripts).
+ Should use CLI for both small/big use cases, instead of having 2 things to do
  the same thing.
+ Support for @files still allows big "presets" to be saved in files.
* Only makes sense when allowing only one "preset at a time, which is ok though.
+ CLI forces simplification of "preset" commands/options because there can't be
  much complexity (such as multiple levels of nested code blocks) on a command
  line.
- It's more difficult to specify complex #define bodies on the command line or
  in general, in a single line (including inside @files). And care must be taken
  with chars special to the shell or @file parser, so escaping may be needed.

Just one "preset" per fbfrog invocation.
+ Allows for the "tiny"/simple CLI
+ Matches the idea that fbfrog works much like a compiler: It takes various
  input files and generates a binding (one binding, not multiple ones).

fbfrog is a single tool, not split up into separate tools: cpp, c2ast, ast2fb
+ All-in-one program is easier to build & use
+ Internals hidden, can easily be changed. With separate tools it'd be necessary
  to start maintaining backwards compatibility etc.
- Prevents manual adjustments to output of individual steps.
+ Wanting to adjust output manually isn't good anyways, because it's too much
  manual work.
- Prevents easy testing of individual steps

No GUI
+ The old GUI was just a frontend for the CLI. Click together a list of input
  files, check some check boxes, click "Go!". That's not a useful GUI...
+ Anyone that wants to create bindings for FB but can't use the CLI can probably
  not be trusted to do a good job anyways
+ No serious ideas for a useful GUI.
  * Compare C headers + FB binding side-by-side, live? Many headers map to 1
    binding, difficult to visualize...
  * Show fbfrog errors inline in the C code, allowing right-clicking to tell
    fbfrog to ignore certain constructs, i.e. build up presets via mouse clicks?
    Lots of work to make an editor like that...

Not preserving white space (i.e. input C code's formatting) and commentary.
+ Creating bindings, not translations. Declarations may be re-ordered.

Should show an error when encountering unknown constructs instead of emitting
the unknown construct and a TODO note into a comment in the .bi output.
+ Forces C parsing support to be improved. Any construct can be parsed, it just
  needs to be implemented.
- Need to support full GCC style C before having the problem go away, that's a
  lot of work. For example inline functions etc. are likely too hard to
  translate properly automatically.
+ C parser is already good enough, unknown constructs are rare in comparison to
  known ones.
- Some constructs (e.g. #defines whose bodies aren't just expressions) cannot be
  supported automatically, they always must be fixed up by the user.
- Having a 90% ok result is better than no result at all. Remaining issues can
  be fixed manually.
+ User must specify proper command line options to fix/work around unknown
  constructs. This means the fixup becomes part of the preset and can easily be
  shared/repeated. Manually fixing unknown construct in the output .bi is not
  acceptable: The user must search through all output .bi files, fix up the
  constructs, and that every time the header is regenerated.

Similar to this: Not automatically/silently removing #defines whose bodies
couldn't be parsed.
+ Error message wouldn't be visible - no cause for exclusion shown = bad.
- Symbols are renamed automatically too

fbfrog should not worry about where input files come from (downloading and
extracting tarballs etc.). Headers may need all kinds of shell commands to be
extracted and prepared, perhaps even execution of a package-specific build
system. fbfrog shoudn't become a portable shell, but instead focus on its job.

It's good to have both -version and -target, without allowing any nesting except
-targets inside -versions.
+ Allowing arbitrary -version nesting has proven difficult for AST merging
  and #if generation code etc.
+ It adds a nesting level which avoids duplicate code... it is nicer than
  doing -version 1.win32 -version 1.linux etc. and that again for other
  versions.
+ target system definitely is the most common nesting within a single
  version, and pretty much the only that matters for FB. Though there also
  is the static vs DLL issue, encoding that into the -version has the same
  problem in the end.
+ -target could nicely be used to auto-add proper pre-#defines, and it's
  very nice for generating #ifdef __FB_WIN32__ etc. checks. Could also use
  -win32/-linux options to behave as if there were -define _WIN32 etc.
  pre-#defines at that position, but then -versiondefine __FB_WIN32__ etc.
  would have to be given manually.
+ -version 1.win32 etc. can still be used, if wanted, to specify all the
  pre-#defines manually.
+ But in general, fbfrog having basic compiler pre-#defines built-in is
  very useful. Otherwise every user would have to worry about them...

All targets should be enabled by default.
+ FB and thus the bindings in general are/should be portable. Even though a
  binding may only be useful on one target, there's no point in enforcing that
  via #if checks.
+ It's probably rare that a C header really won't compile for a certain target,
  e.g. due to an #error, but if that ever is a problem, a -disabletarget option
  could be added to fbfrog.
+ Improved usability: -target can still be used to add -target options, but it
  won't specify which targets are enabled or disabled anymore. Enabling all
  targets while having target-specific options for some no longer requires
  passing a -target option for each target, which would become more and more
  annoying as the number of targets increases (dos/linux/win32 + missing ones,
  32bit/64bit, x86/ARM + missing ones...)

Typedef vs struct/union/enum tag symbols handling
* FB doesn't have separate type/tag namespaces, so this always must be fixed.
* Better automatically than manually, except for polishing.
* <struct UDT> should just become <UDT> where possible
* It's not possible if there already is an <UDT> typedef
* If it's a redundant typedef though (<typedef struct UDT UDT;>) then it can
  just be removed.
* Otherwise, if <UDT> and <struct UDT> represent different things, one must be
  renamed, and all references to it (but not to the other) must be updated.
* Such conflicts are probably not a common problem
* Symbol name conflict check can handle this too, provided that the C parser
  preserves the information on whether a subtype was <UDT> or <struct UDT>.
* That's better than aborting with an error or not detecting the issue at all.
* The user can still specify -rename command line options if needed.

No expression folding/constant evaluation for initializers/#define expressions.
+ Never really needed, rarely ever useful - it's purely a coding style thing.
  But if an expression was written a certain way in a C header, then there's
  probably a reason for it, for example to make its value easier to understand.
  Folding would destroy that.
+ Avoids lots of ugly code
- Converting C expressions to FB may become more difficult due to the different
  operator/data type semantics. Having fbfrog calculate the expressions using
  the C semantics would avoid the issue.
+ But that problem exists for non-constant expressions aswell anyways, so must
  be solved differently.

No -undef command line option to allow adding pre-#undefs. The CPP already
treats all unknown symbols as undefined. The only purpose of -undef would be to
suppress the "assuming undefined" warnings, but specifying an -undef for all
known-to-be-undefined symbols seems excessive and unmaintainable, i.e. not
really useful in practice.

#undefs and duplicate/conflicting #defines aren't preserved.
1. #undefs and overridden/undef'ed #defines aren't part of the public API, but
   more like internal helpers used by headers.
2. The CPP does macro expansion etc. anyways, so the internal helper macros
   aren't needed.
so preserving them is not useful.
