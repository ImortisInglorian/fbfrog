
  fbfrog -- FreeBASIC binding generator
  Copyright (C) 2011 - 2014  Daniel C. Klauer <daniel.c.klauer[at]web.de>

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.


What's this?

  fbfrog is a tool that reads *.h files (C API declarations) and generates a
  corresponding *.bi file (FreeBASIC API declarations). It's intended to
  automate most of the work needed to create and maintain FB bindings for C
  libraries.

  C and FB are similar enough to allow most declarations to be converted 1:1 by
  doing a pure syntax conversion, for example:
      struct UDT {              =>    type UDT
          float f;              =>        f as single
      };                        =>    end type
      void f(struct UDT *p);    =>    declare sub f(byval p as UDT ptr)

  Besides that, fbfrog performs the following "high-level" transformations:
   * C types + size_t/int32_t/... => FB types
   * char => byte, char* => zstring ptr, char[N] => zstring * N
   * Most used calling convention => Extern block
   * Other calling conventions (if header uses multiple ones) => emitted on
     individual procedures
   * Function/array typedefs (not supported in FB) => solved out
   * Array parameters (not supported in FB) => pointers
   * jmp_buf parameters => pointers (jmp_buf is a UDT in FB, not an array type)
   * Anonymous structs (not supported in FB) => named after first typedef that
     uses them, or auto-generated name
   * typedef struct FOO FOO; => solved out (FB doesn't have separate types/tags)
   * #defines nested inside struct bodies => moved to toplevel (helps when
     converting #defines to constants, because FB scopes those inside UDTs)
   * #define m(a, ...) __VA_ARGS__ => #define m(a, __VA_ARGS__...) __VA_ARGS__
   * Symbol name conflicts with FB keywords or each-other, for example due to
     FB's case insensitivity, => automatically renamed by appending _
     underscores to the less important symbol
   * Renamed variables/procedures => ALIAS "<original-name>" will be emitted
   * Named enum => type enumname as long + anonymous enum
     (C enums/ints stay 32bit on 64bit, so in FB we have to use the always-32bit
     LONG type instead of the default ENUM/INTEGER type)
   * #pragma comment(lib, "foo.lib"|"libfoo.a") => #inclib "foo"

  Declarations which cannot be processed automatically (yet) will be embedded
  into the *.bi file in form of a "TODO" comment, for example:
    '' TODO: #define FOO ...
  This affects:
   * Complicated #defines ("arbitrary" token sequences)
   * Function bodies (inline functions)
   * Plus some others (you'll see; most things should be supported by now, but
     there's always something missing...)

  fbfrog preprocesses and parses the input headers multiple times: once for each
  supported target (DOS/Linux/Windows, x86/x86_64) and merges all these APIs
  together into the final binding. If you need to override this (for example if
  your .h files don't support DOS and have an #error statement for this case),
  then use -nodefaultscript and specify the needed targets manually (see
  include/fbfrog/default.fbfrog for an example).


Compiling:
  fbc *.bas -m fbfrog

Running the tests:
  1. fbc tests/run.bas
  2. tests/run
  3. Use Git to check the status of the tests/ directory.
     Any changes indicate test failures.


Usage:

  Run fbfrog and pass the *.h file(s) on the command line:
    fbfrog foo.h

  It's only necessary to pass the "entry points" - the header(s) that you would
  #include in a C program. fbfrog expands all #includes it can find.
  The generated binding will cover the API that would become available by
  #including those headers in the given order. Separate headers that aren't
  intended to be #included together shouldn't be passed to fbfrog together, but
  in separate invocations.

  If fbfrog can't find #included header files, you can use this option:
    -incdir <path>
  Sometimes this is needed to allow the main header to be parsed successfully.
  (for example, a macro can only be expanded if the #define statement was seen)

  Use the -filterout <filename-pattern> option to exclude the content of certain
  headers from the final binding:
    fbfrog gtk.h -filterout '*glib*' -filterout '*gdk*'

  The .bi file generated by fbfrog needs to be reviewed and tested. TODOs must
  be fixed up manually.


Using the -declare*/-select/-ifdef options:

  fbfrog is able to read multiple headers or multiple versions of the same
  header (preprocessed differently) and merge them into a single binding.
  1. This is used to support multiple targets (DOS/Linux/Win32, x86/x86_64):
     Instead of looking for #ifs in the input headers and possibly trying to
     preserve those, fbfrog preprocesses and parses the input header files
     multiple times (using different predefines each time), and then merges the
     resulting target-specific APIs into one final binding, by (re-)inserting
     #ifs (such as #ifdef __FB_WIN32__) where needed.
  2. and by using the -declare* command line options yourself you can combine
     pretty much any APIs, for example version 1.0 and 2.0 of a library, or the
     ANSI and UNICODE versions of a Win32-specific header. Of course it only
     makes sense if the APIs belong together. Sometimes the merging algorithm
     produces a rather ugly result though, especially if the differences between
     the APIs are too big, so it's not always useful.

  Assuming we have the header files foo1.h and foo2.h, let's use the following
  fbfrog options:

    -declareversions __LIBFOO_VERSION 1 2
    -select __LIBFOO_VERSION
    -case 1
        foo1.h
    -case 2
        foo2.h
    -endselect

  Save those options into a foo.fbfrog helper file (because it's too much to
  type at the command line), and pass it to fbfrog:

    fbfrog foo.fbfrog

  The created binding will allow the user to #define __LIBFOO_VERSION to 1 or
  2 in order to select that specific API version:

    [...declarations that existed in both foo1.h and foo2.h...]
    #if __LIBFOO_VERSION = 1
        [...declarations that existed only in foo1.h...]
    #else
        [...declarations that existed only in foo2.h...]
    #endif
    [...etc...]

  You can use -declare* options as wanted to support multiple APIs in 1 binding:

    -declareversions <symbol> <numbers...>
        Useful to allow selecting an API by version. This will produce #if
        blocks such as #if <symbol> = <number>.

    -declaredefines <symbol1> <symbol2> <symbol3>
        Useful to allow selectin an API by #defining a certain symbol. This is
        used in default.fbfrog to allow selecting an OS-specific API based on
        the __FB_DOS__/__FB_LINUX__/__FB_WIN32__ #defines, but it could be used
        for other things aswell. This will produce #if blocks such as #ifdef
        <symbol1>. The symbols are assumed to be #defined exclusively - only one
        at a time.

    -declarebool <symbol>
        Useful to allow API selection based on whether a certain symbol is
        defined or not. This is used for __FB_64BIT__ in default.fbfrog, but
        could also be used to support distinguishing between UNICODE and ANSI
        versions of a binding (-declarebool UNICODE -> #ifdef UNICODE) or
        the shared library/DLL version and the static library version, etc.

  If multiple -declare* options are given, they multiply. For example:
    -declarebool A -declarebool B
  produces these APIs:
         defined(A)  and      defined(B)
         defined(A)  and (not defined(B))
    (not defined(A)) and      defined(B)
    (not defined(A)) and (not defined(B))

  You can use the -select/-ifdef logic options to create different "code paths"
  where some options will only be used for some APIs (instead of applying to
  all APIs). This also works with -declare* options, allowing you to build
  even complex API condition trees. See for example
  include/fbfrog/default.fbfrog, which declares 64bit versions for all systems
  except DOS.


Why use a custom C preprocessor and parser instead of an existing one?
  fbfrog wants to do things that existing preprocessors/parsers don't support:
    * preserve #defines and parse their bodies
    * selective/optional expansion of macros and #includes
    * fully configurable pre-#defines, no hard-coded target/compiler-specifics
    * modify the AST to make it FB-friendly, insert FB-specific constructs


Why make fbfrog a standalone tool? How about integrating C parsing (or rather,
a binding creation tool) into fbc itself directly, so bindings would become
unnecessary?
  1. Until we can translate all constructs to FB automatically, the .bi files
     are needed as a "buffer" where we can fix things up manually.
  2. fbc's existing lexing/preprocessing/parsing code could not be reused to
     parse C headers, because it's way too different from C. Thus it'd be
     necessary to maintain a full binding creation tool as part of fbc, and it'd
     be more or less the same amount of work as keeping it separate -- although
     having it included in fbc would probably be more convenient for the user.
  3. fbc is the FB compiler, not a C compiler, and FB itself should be good
     enough to specify the API/ABI for accessing external libraries.
  4. Users may expect to be able to interact with the #included .h file directly
     by using FB #define statements etc., but that wouldn't be possible unless
     we had an FB-to-C translator too.


To do:

* Currently tag ids are preserved as type names, but often this is unnecessary.
  If we find an alias typedef for a tag id (no matter whether it's an exact
  alias or a different id alias) then the tag id should be solved out. All uses
  should be changed to use the typedef.

* Renames can cause other renames to become unnecessary. Here we'll do an
  unnecessary rename:
	#define A 1
	struct UDT { int a; };
	enum { a = 1 };
  The field causes the #define to be renamed, so the enumconst doesn't have to
  be renamed anymore. This only happens because of the inter-namespace rename
  (due to the field/#define conflict) and because enumcontants are preferred
  over #defines when renaming.

* Support dimension-less arrays with initializers: int a[] = {1, 2};

* Simplify CLI
  * string-based arg parsing, instead of tk/lex
  * Support -DFOO=1 and -I<path> options like gcc and for pkg-config,
    the -define <id> [<body>] syntax is confusing
  * -select/-if options should already include -declare, it doesn't need to be
    separate ever
* Rework console output, it quickly becomes too much currently. Perhaps the
  #includes should be emitted into the .bi, like renamelists.
* Can't renamelists be generated based on ALIAS'es later, separate from astFixIds?
* Add proper symbol table to speed up symbol renaming & identifier comparisons
* Optimize tk access, at least for the C parser which shouldn't need insert/delete
  anymore. Test performance with array instead of gap buffer. Ideally everything
  would work with the current line only, not the entire input file.

- Continue support for parsing function bodies: if/else blocks, for/while/do/while
  loops, local vars, assignments, goto, break, return, switch, labels including 'case'.
  - change hScopeBlockOrInitializer(): depending on context it doesn't need and
    shouldn't do this disambiguation
  - Scope block parsing should be the same as parsing function bodies
  - Identifier fixup inside scopes
  - How to handle assignments in the middle of expressions or as if/while conditions?
        if (a = 1) ...          =>    a = 1 : if a then ...
        if (a = 1 && b = 2) ... =>    a = 1 : if a then : b = 2 : if b then ... : end if
    ?: and &&/|| operands containing assignments must be expanded to real if blocks.
